// widgets/dream_journal_widget.dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:dreamr/models/dream.dart';
import 'package:dreamr/services/api_service.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:intl/intl.dart';

// NEW: use your existing downloader + auth'd Dio to save images to disk
import 'package:dreamr/services/image_store.dart';
import 'package:dreamr/services/dio_client.dart';

class DreamJournalWidget extends StatefulWidget {
  final VoidCallback? onDreamsLoaded;

  const DreamJournalWidget({
    super.key,
    this.onDreamsLoaded,
  });

  @override
  State<DreamJournalWidget> createState() => DreamJournalWidgetState();
}

class ToneStyle {
  final Color background;
  final Color text;
  const ToneStyle(this.background, this.text);
}

class DreamJournalWidgetState extends State<DreamJournalWidget> {
  List<Dream> _dreams = [];
  List<Dream> getDreams() => _dreams;

  final Map<int, bool> _expanded = {};
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _loadDreams();
  }

  ToneStyle _getToneStyle(String tone) {
    final t = tone; // no normalization; your constants match exactly
    switch (t) {
      case 'peaceful / gentle':
        return ToneStyle(Colors.blue.shade100, Colors.black87);
      case 'epic / heroic':
        return ToneStyle(Colors.orange.shade100, Colors.black87);
      case 'whimsical / surreal':
        return ToneStyle(Colors.purple.shade100, Colors.black87);
      case 'nightmarish / dark':
        return ToneStyle(Colors.grey.shade900, Colors.orange.shade200);
      case 'romantic / nostalgic':
        return ToneStyle(Colors.pink.shade100, Colors.black87);
      case 'ancient / mythic':
        return ToneStyle(Colors.brown.shade100, Colors.black87);
      case 'futuristic / uncanny':
        return ToneStyle(Colors.teal.shade100, Colors.black87);
      case 'elegant / ornate':
        return ToneStyle(Colors.indigo.shade100, Colors.black87);
      default:
        return ToneStyle(Colors.grey.shade100, Colors.black87);
    }
  }

  // ---- DATA ----
  Future<void> _loadDreams() async {
    try {
      final dreams = await ApiService.fetchDreams();
      setState(() {
        _dreams = dreams;
        _loading = false;
      });

      // Background prefetch of thumbnails ONLY (non-blocking, fire-and-forget)
      // Keeps UI smooth. Full images are saved when the row expands.
      for (final d in dreams) {
        if ((d.imageTile ?? '').isNotEmpty) {
          // ignore: discarded_futures
          ImageStore.download(d.id, DreamImageKind.tile, d.imageTile!, dio: DioClient.dio).catchError((_) {});
        }
      }

      widget.onDreamsLoaded?.call();
    } catch (_) {
      setState(() => _loading = false);
    }
  }

  void refresh() {
    setState(() => _loading = true);
    _loadDreams();
  }

  // ---- UI ----
  @override
  Widget build(BuildContext context) {
    if (_loading) return const Center(child: CircularProgressIndicator());
    if (_dreams.isEmpty) return const Text("Your Dreams will appear here...");

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 0),
      child: ListView.builder(
        padding: EdgeInsets.zero,
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: _dreams.length,
        itemBuilder: (context, index) {
          final dream = _dreams[index];
          final isExpanded = _expanded[dream.id] ?? false;
          final toneStyle = _getToneStyle(dream.tone);

          final formattedDate = DateFormat('EEE, MMM d, y h:mm a')
              .format(dream.createdAt.toLocal());

          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 3),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: toneStyle.background,
                borderRadius: BorderRadius.circular(4),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Header row: thumb + text block (tap to expand)
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        _expanded[dream.id] = !isExpanded;
                      });
                    },
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if ((dream.imageTile ?? '').isNotEmpty)
                          _TileThumb(dream: dream, radius: 4, size: 48),
                        if ((dream.imageTile ?? '').isNotEmpty)
                          const SizedBox(width: 6),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                formattedDate,
                                style: TextStyle(
                                  fontSize: 12,
                                  color: toneStyle.text,
                                ),
                              ),
                              Text(
                                dream.summary,
                                style: TextStyle(
                                  fontWeight: FontWeight.bold,
                                  fontSize: 13,
                                  color: toneStyle.text,
                                ),
                              ),
                              Text(
                                dream.tone,
                                style: TextStyle(
                                  fontSize: 10,
                                  fontStyle: FontStyle.italic,
                                  color: toneStyle.text,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),

                  // Expanded content
                  if (isExpanded)
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (dream.text.isNotEmpty) ...[
                          SelectableRegion(
                            focusNode: FocusNode(),
                            selectionControls:
                                MaterialTextSelectionControls(),
                            child: Text(
                              dream.text,
                              style: TextStyle(
                                fontSize: 13,
                                fontStyle: FontStyle.italic,
                                color: toneStyle.text,
                              ),
                            ),
                          ),
                          const SizedBox(height: 10),
                        ],
                        if (dream.analysis.isNotEmpty) ...[
                          Text(
                            "Analysis:",
                            style: TextStyle(
                              fontSize: 13,
                              fontWeight: FontWeight.bold,
                              color: toneStyle.text,
                            ),
                          ),
                          MarkdownBody(
                            data: dream.analysis,
                            styleSheet: MarkdownStyleSheet.fromTheme(
                              Theme.of(context),
                            ).copyWith(
                              p: TextStyle(
                                  color: toneStyle.text, fontSize: 12),
                              strong: TextStyle(
                                  color: toneStyle.text,
                                  fontWeight: FontWeight.bold),
                              em: TextStyle(
                                  color: toneStyle.text,
                                  fontStyle: FontStyle.italic),
                              h1: TextStyle(
                                  color: toneStyle.text,
                                  fontSize: 18,
                                  fontWeight: FontWeight.bold),
                              h2: TextStyle(
                                  color: toneStyle.text,
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold),
                            ),
                          ),
                          const SizedBox(height: 6),
                        ],
                        if ((dream.imageFile ?? '').isNotEmpty)
                          _PrefetchingFullImage(
                            dreamId: dream.id,
                            url: dream.imageFile!,
                            borderRadius: 8,
                          ),
                      ],
                    ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}

/// Small thumbnail that shows from disk if available, otherwise uses the network
/// immediately (for smoothness) and saves to disk in the background.
class _TileThumb extends StatefulWidget {
  const _TileThumb({
    required this.dream,
    this.radius = 4,
    this.size = 48,
  });

  final Dream dream;
  final double radius;
  final double size;

  @override
  State<_TileThumb> createState() => _TileThumbState();
}

class _TileThumbState extends State<_TileThumb> {
  File? _file;

  @override
  void initState() {
    super.initState();
    _init();
  }

  Future<void> _init() async {
    final url = widget.dream.imageTile!;
    // If we already have it, use the file immediately
    final existing = await ImageStore.localIfExists(
      widget.dream.id,
      DreamImageKind.tile,
      url,
    );
    if (mounted && existing != null) {
      setState(() => _file = existing);
    } else {
      // Always kick a background save for next time; no UI wait
      // ignore: discarded_futures
      ImageStore.download(
        widget.dream.id,
        DreamImageKind.tile,
        url,
        dio: DioClient.dio,
      ).catchError((_) {});
    }
  }

  @override
  Widget build(BuildContext context) {
    final r = BorderRadius.circular(widget.radius);
    final w = widget.size, h = widget.size;

    if (_file != null) {
      return ClipRRect(
        borderRadius: r,
        child: Image.file(_file!, width: w, height: h, fit: BoxFit.cover),
      );
    }

    // Use network immediately for smooth first paint; file will be used next render
    return ClipRRect(
      borderRadius: r,
      child: Image.network(
        widget.dream.imageTile!,
        width: w,
        height: h,
        fit: BoxFit.cover,
        cacheWidth: (w * 2).round(), // small decode for perf
        cacheHeight: (h * 2).round(),
        gaplessPlayback: true,
        filterQuality: FilterQuality.low,
      ),
    );
  }
}

/// Full-size image that displays from network (smooth) and saves to disk
/// in background; on next open it will render from file immediately.
class _PrefetchingFullImage extends StatefulWidget {
  const _PrefetchingFullImage({
    required this.dreamId,
    required this.url,
    this.borderRadius = 8,
  });

  final int dreamId;
  final String url;
  final double borderRadius;

  @override
  State<_PrefetchingFullImage> createState() => _PrefetchingFullImageState();
}

class _PrefetchingFullImageState extends State<_PrefetchingFullImage> {
  File? _file;

  @override
  void initState() {
    super.initState();
    _init();
  }

  Future<void> _init() async {
    final existing = await ImageStore.localIfExists(
      widget.dreamId,
      DreamImageKind.file,
      widget.url,
    );
    if (mounted && existing != null) {
      setState(() => _file = existing);
    } else {
      // Background save; do not block UI or swap mid-scroll
      // ignore: discarded_futures
      ImageStore.download(
        widget.dreamId,
        DreamImageKind.file,
        widget.url,
        dio: DioClient.dio,
      ).catchError((_) {});
    }
  }

  @override
  Widget build(BuildContext context) {
    final r = BorderRadius.circular(widget.borderRadius);

    if (_file != null) {
      return ClipRRect(
        borderRadius: r,
        child: Image.file(_file!, fit: BoxFit.cover),
      );
    }

    return ClipRRect(
      borderRadius: r,
      child: Image.network(
        widget.url,
        fit: BoxFit.cover,
        gaplessPlayback: true,
        filterQuality: FilterQuality.low,
      ),
    );
  }
}
