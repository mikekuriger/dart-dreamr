// widgets/dream_journal_widget.dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:intl/intl.dart';

import 'package:dreamr/models/dream.dart';
import 'package:dreamr/state/dream_list_model.dart';
import 'package:dreamr/services/image_store.dart';
import 'package:dreamr/services/dio_client.dart';


class DreamJournalWidget extends StatefulWidget {
  const DreamJournalWidget({
    super.key,
    this.onDreamsLoaded,
  });

  final VoidCallback? onDreamsLoaded;

  @override
  DreamJournalWidgetState createState() => DreamJournalWidgetState();
}

class DreamJournalWidgetState extends State<DreamJournalWidget> {
  List<Dream> _snapshot = const [];

  /// Allows parent (via GlobalKey) to ask for current dreams.
  List<Dream> getDreams() => List.unmodifiable(_snapshot);

  /// Allows parent to force a sync refresh.
  Future<void> refresh() async {
    await context.read<DreamListModel>().refresh();
  }

  @override
  Widget build(BuildContext context) {
    final model = context.watch<DreamListModel>();
    final dreams = model.dreams;
    // Keep a local copy so _journalKey.currentState!.getDreams() works.
    _snapshot = dreams;

    // Notify parent that dreams are loaded/changed (for stats).
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted && widget.onDreamsLoaded != null) widget.onDreamsLoaded!();
    });

    if (model.loading && dreams.isEmpty) {
      return const Padding(
        padding: EdgeInsets.only(top: 48),
        child: Center(child: CircularProgressIndicator()),
      );
    }
    if (dreams.isEmpty) {
      return const Padding(
        padding: EdgeInsets.only(top: 120),
        child: Center(child: Text('No dreams yet.', style: TextStyle(color: Colors.white70))),
      );
    }

    // return ListView.separated(
    //   shrinkWrap: true,
    //   physics: const NeverScrollableScrollPhysics(),
    //   itemCount: dreams.length,
    //   separatorBuilder: (_, __) => const SizedBox(height: 6),
    //   itemBuilder: (ctx, i) => _DreamRow(dream: dreams[i]),
    // );
    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(), // parent scrolls
      itemCount: dreams.length,
      itemBuilder: (ctx, i) => _DreamRow(dream: dreams[i]),
      addAutomaticKeepAlives: false,
      addRepaintBoundaries: true,
      addSemanticIndexes: false,
      cacheExtent: 600, // preload a little ahead
    );
  }
}

class _DreamRow extends StatelessWidget {
  const _DreamRow({required this.dream});
  final Dream dream;

  @override
  Widget build(BuildContext context) {
    final color = _toneColor(dream.tone);          // dot color
    final dateStr = _formatDateTime(dream.createdAt);

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () => _openDetail(context, dream),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.black12.withValues(alpha: 0.10),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: color.withValues(alpha: 0.45), width: 1),
          ),
          padding: const EdgeInsets.all(10),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // thumbnail on the left
              const SizedBox(width: 2),
              _Thumb(dream: dream),
              const SizedBox(width: 10),

              // text block on the right
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // TOP ROW: date/time
                    Text(
                      dateStr,
                      style: const TextStyle(fontSize: 12, color: Colors.white70),
                    ),
                    const SizedBox(height: 4),

                    // SUMMARY
                    Text(
                      dream.summary.isNotEmpty ? dream.summary : dream.text,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w700,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 6),

                    // TONE LINE: colored dot + original tone string
                    Row(
                      children: [
                        Container(
                          width: 8, height: 8,
                          decoration: BoxDecoration(color: color, shape: BoxShape.circle),
                        ),
                        const SizedBox(width: 6),
                        Flexible(
                          child: Text(
                            dream.tone.isEmpty ? '—' : _titleCase(dream.tone),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: const TextStyle(
                              fontSize: 13,
                              color: Colors.white70,
                              fontStyle: FontStyle.italic,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


class _Thumb extends StatefulWidget {
  const _Thumb({required this.dream});
  final Dream dream;

  @override
  State<_Thumb> createState() => _ThumbState();
}

class _ThumbState extends State<_Thumb> {
  File? _file;
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _resolve();
  }

  Future<void> _resolve() async {
    final url = widget.dream.imageTile ?? widget.dream.imageFile;
    if (url == null || url.isEmpty) {
      setState(() => _loading = false);
      return;
    }
    final kind = widget.dream.imageTile != null ? DreamImageKind.tile : DreamImageKind.file;

    // show local file if present
    final existing = await ImageStore.localIfExists(widget.dream.id, kind, url);
    if (existing != null) {
      setState(() { _file = existing; _loading = false; });
      return;
    }

    // show network thumb immediately; download in background and swap in when finished
    setState(() => _loading = false);
    // fire-and-swap
    // ignore: discarded_futures
    ImageStore.download(widget.dream.id, kind, url, dio: DioClient.dio).then((f) {
      if (!mounted) return;
      setState(() => _file = f);
    });
  }

  @override
  Widget build(BuildContext context) {
    final size = 56.0;
    if (_file != null) {
      return ClipRRect(
        borderRadius: BorderRadius.circular(8),
        child: SizedBox(width: size, height: size, child: Image.file(_file!, fit: BoxFit.cover)),
      );
    }

    // while downloading (or if no local yet), use the network image sized as a thumb
    final url = widget.dream.imageTile ?? widget.dream.imageFile;
    return ClipRRect(
      borderRadius: BorderRadius.circular(8),
      child: SizedBox(
        width: size, height: size,
        child: url == null || url.isEmpty
          ? const ColoredBox(color: Color(0x22000000))
          : Image.network(url, fit: BoxFit.cover, cacheWidth: 112, cacheHeight: 112),
      ),
    );
  }
}


Future<void> _openDetail(BuildContext context, Dream d) async {
  final url = d.imageFile ?? d.imageTile;
  final color = _toneColor(d.tone);

  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    backgroundColor: const Color(0xFF1A1A1A),
    shape: const RoundedRectangleBorder(
      borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
    ),
    builder: (ctx) {
      return SafeArea(
        child: Padding(
          padding: const EdgeInsets.fromLTRB(16, 12, 16, 24),
          child: SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // header
                Row(
                  children: [
                    Container(width: 10, height: 10, decoration: BoxDecoration(color: color, shape: BoxShape.circle)),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        _shortDate(d.createdAt),
                        style: const TextStyle(color: Colors.white70, fontSize: 12),
                      ),
                    ),
                    IconButton(
                      tooltip: 'Share',
                      icon: const Icon(Icons.ios_share, color: Colors.white70),
                      onPressed: () async => shareDreamImage(d),
                    ),
                  ],
                ),
                const SizedBox(height: 10),

                // big image (if present)
                if (url != null && url.isNotEmpty) _DetailImage(dream: d),

                const SizedBox(height: 12),
                if (d.summary.isNotEmpty)
                  Text(d.summary, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w700, color: Colors.white)),
                if (d.summary.isNotEmpty) const SizedBox(height: 10),

                // full text
                if (d.text.isNotEmpty)
                  Text(d.text, style: const TextStyle(fontSize: 14, color: Colors.white)),
                const SizedBox(height: 16),

                // analysis
                if (d.analysis.isNotEmpty) ...[
                  const Text('Analysis', style: TextStyle(fontWeight: FontWeight.bold, color: Colors.white70)),
                  const SizedBox(height: 6),
                  Text(d.analysis, style: const TextStyle(fontSize: 14, color: Colors.white)),
                ],
              ],
            ),
          ),
        ),
      );
    },
  );
}

class _DetailImage extends StatefulWidget {
  const _DetailImage({required this.dream});
  final Dream dream;

  @override
  State<_DetailImage> createState() => _DetailImageState();
}

class _DetailImageState extends State<_DetailImage> {
  File? _file;
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _resolve();
  }

  Future<void> _resolve() async {
    final url = widget.dream.imageFile ?? widget.dream.imageTile;
    if (url == null || url.isEmpty) {
      setState(() => _loading = false);
      return;
    }
    final kind = widget.dream.imageFile != null ? DreamImageKind.file : DreamImageKind.tile;
    final existing = await ImageStore.localIfExists(widget.dream.id, kind, url);
    if (existing != null) {
      setState(() { _file = existing; _loading = false; });
      return;
    }
    try {
      final f = await ImageStore.download(widget.dream.id, kind, url, dio: DioClient.dio);
      if (mounted) setState(() { _file = f; _loading = false; });
    } catch (_) {
      if (mounted) setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return AspectRatio(
        aspectRatio: 16/9,
        child: Container(color: const Color(0x22000000)),
      );
    }
    if (_file != null) {
      return ClipRRect(
        borderRadius: BorderRadius.circular(10),
        child: Image.file(_file!, fit: BoxFit.cover),
      );
    }
    final url = widget.dream.imageFile ?? widget.dream.imageTile;
    return (url != null && url.isNotEmpty)
        ? ClipRRect(
            borderRadius: BorderRadius.circular(10),
            child: Image.network(url, fit: BoxFit.cover),
          )
        : const SizedBox.shrink();
  }
}



Color _toneColor(String tone) {
    switch (tone) {
      case 'peaceful / gentle':
        return const Color(0xFF34D399); // green
      case 'epic / heroic':
        return const Color(0xFF60A5FA); // blue
      case 'whimsical / surreal':
        return const Color(0xFF22D3EE); // cyan
      case 'nightmarish / dark':
        return const Color(0xFFEF4444); // red
      case 'romantic / nostalgic':
        return const Color(0xFFFF7AB6); // pink
      case 'ancient / mythic':
        return const Color(0xFFF97316); // orange-deep
      case 'futuristic / uncanny':
        return const Color(0xFFFFC857); // amber
      case 'elegant / ornate':
        return const Color(0xFFA78BFA); // violet-light
      default:
        return const Color(0xFF9CA3AF); // gray
    }
  }

String _formatDateTime(DateTime dt) {
  // Example: "Sep 16, 2025 • 3:41 PM"
  return DateFormat('MMM d, yyyy • h:mm a').format(dt);
}


String _titleCase(String s) => s.split(RegExp(r'\s+'))
    .map((w) => w.isEmpty ? w : (w[0].toUpperCase() + w.substring(1)))
    .join(' ');


String _shortDate(DateTime dt) {
  // yyyy-MM-dd
  final m = dt.month.toString().padLeft(2, '0');
  final d = dt.day.toString().padLeft(2, '0');
  return '${dt.year}-$m-$d';
}

Future<void> shareDreamImage(Dream d) async {
  final url = d.imageTile ?? d.imageFile;
  if (url == null || url.isEmpty) return;
  final kind = d.imageTile != null ? DreamImageKind.tile : DreamImageKind.file;
  final f = await ImageStore.fileFor(d.id, kind, url);
  if (!await f.exists()) return;
  await Share.shareXFiles([XFile(f.path)],
      text: d.summary.isNotEmpty ? d.summary : 'My dream ✨');
}
